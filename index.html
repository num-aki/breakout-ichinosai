<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <title>Breakout Game - Ichinosai style</title>
  <!-- Import Google Fonts for Japanese typography -->
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet"/>
  <style>
    /* Global Styles */
    body {
      margin: 0;
      font-family: 'Noto Sans JP', sans-serif;
      color: #ddd;
      background-color: #0d0d0d;
    }
    a { color: inherit; text-decoration: none; }
    /* Header and navigation */
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 2rem;
      border-bottom: 1px solid #333;
      background-color: #0d0d0d;
    }
    header .logo a {
      font-weight: bold;
      font-size: 1.2rem;
      color: #fff;
    }
    nav ul {
      list-style: none;
      display: flex;
      gap: 1.5rem;
      margin: 0;
      padding: 0;
    }
    nav a {
      color: #ddd;
      font-size: 0.9rem;
      transition: color 0.2s;
    }
    nav a:hover {
      color: #fff;
    }
    /* Main content */
    main {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem;
    }
    .hero {
      text-align: center;
      margin-bottom: 2rem;
    }
    .hero h1 {
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }
    .hero p {
      font-size: 1rem;
      color: #999;
    }
    .game-container {
      display: flex;
      flex-wrap: wrap;
      gap: 2rem;
      width: 100%;
      max-width: 1000px;
      justify-content: center;
    }
    canvas {
      border: 1px solid #444;
      background-color: #111;
    }
    /* Sidebar panel */
    aside {
      flex: 1;
      min-width: 200px;
      background-color: #151515;
      padding: 1rem;
      border: 1px solid #444;
      border-radius: 4px;
    }
    aside h2 {
      margin-top: 0;
      font-size: 1.2rem;
    }
    aside p {
      margin: 0.5rem 0;
      font-size: 0.9rem;
      color: #bbb;
    }
    aside input[type="range"] {
      width: 100%;
    }
    /* Footer */
    footer {
      margin-top: 3rem;
      padding: 1rem;
      text-align: center;
      font-size: 0.8rem;
      color: #666;
      border-top: 1px solid #333;
    }
    footer a {
      color: #666;
      margin: 0 0.5rem;
    }
    footer a:hover {
      color: #999;
    }
  </style>
</head>
<body>
  <header>
    <div class="logo"><a href="#">Ichinosai</a></div>
    <nav>
      <ul>
        <li><a href="#">Top</a></li>
        <li><a href="#">Collections</a></li>
        <li><a href="#">Products</a></li>
        <li><a href="#">About</a></li>
        <li><a href="#">Career</a></li>
        <li><a href="#">Contact</a></li>
      </ul>
    </nav>
  </header>
  <main>
    <div class="hero">
      <h1>ブロック崩しゲーム</h1>
      <p>IchinosaiスタイルのHTMLゲームをお楽しみください</p>
    </div>
    <div class="game-container">
      <canvas id="game" width="900" height="600"></canvas>
      <aside>
        <h2>操作説明</h2>
        <p>← → キーでパドルを移動し、スペースキーで開始・一時停止。</p>
        <p>速度:<br/><input type="range" id="speed" min="3" max="12" value="6"></p>
        <p>スコア: <span id="score">0</span></p>
        <p>レベル: <span id="level">1</span></p>
        <p>ライフ: <span id="lives">3</span></p>
      </aside>
    </div>
  </main>
  <footer>
    <p><a href="#">プライバシーポリシー</a> | <a href="#">利用規約</a> | &copy; 2025 Ichinosai</p>
  </footer>
  <script>
    // Game configuration and state
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const PADDLE = { w: 120, h: 15, x: canvas.width / 2 - 60, y: canvas.height - 30 };
    const BALL = { r: 8, x: canvas.width / 2, y: canvas.height - 50, dx: 4, dy: -4, speed: 6 };
    let ROWS = 4;
    let COLS = 12;
    const BRICK = { w: (canvas.width - 80) / COLS, h: 20, padding: 5, offsetX: 40, offsetY: 60 };
    let bricks = [];
    let score = 0;
    let level = 1;
    let lives = 3;
    let running = false;
    let leftPressed = false;
    let rightPressed = false;

    // Initialize bricks matrix
    function initBricks() {
      bricks = [];
      for (let r = 0; r < ROWS; r++) {
        bricks[r] = [];
        for (let c = 0; c < COLS; c++) {
          bricks[r][c] = { x: 0, y: 0, status: 1 };
        }
      }
    }
    initBricks();

    // Draw bricks
    function drawBricks() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const b = bricks[r][c];
          if (b.status === 1) {
            const x = BRICK.offsetX + c * (BRICK.w + BRICK.padding);
            const y = BRICK.offsetY + r * (BRICK.h + BRICK.padding);
            bricks[r][c].x = x;
            bricks[r][c].y = y;
            // Draw brick base layer
            ctx.fillStyle = '#444';
            ctx.fillRect(x, y, BRICK.w, BRICK.h);
            // Draw brick inner layer for depth effect
            ctx.fillStyle = '#888';
            ctx.fillRect(x + 2, y + 2, BRICK.w - 4, BRICK.h - 4);
          }
        }
      }
    }

    // Draw paddle
    function drawPaddle() {
      ctx.fillStyle = '#999';
      ctx.fillRect(PADDLE.x, PADDLE.y, PADDLE.w, PADDLE.h);
    }

    // Draw ball
    function drawBall() {
      ctx.beginPath();
      ctx.arc(BALL.x, BALL.y, BALL.r, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();
      ctx.closePath();
    }

    // Update displayed scores and info
    function updateInfo() {
      document.getElementById('score').textContent = score;
      document.getElementById('level').textContent = level;
      document.getElementById('lives').textContent = lives;
    }

    // Collision detection between ball and bricks
    function collisionDetection() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const b = bricks[r][c];
          if (b.status === 1) {
            if (
              BALL.x > b.x &&
              BALL.x < b.x + BRICK.w &&
              BALL.y > b.y &&
              BALL.y < b.y + BRICK.h
            ) {
              BALL.dy = -BALL.dy;
              b.status = 0;
              score++;
              if (score % (ROWS * COLS) === 0) {
                // Level up when all bricks are destroyed
                level++;
                ROWS++;
                lives++;
                initBricks();
                resetBall();
              }
            }
          }
        }
      }
    }

    // Reset ball position and direction
    function resetBall() {
      BALL.x = canvas.width / 2;
      BALL.y = canvas.height - 50;
      // Randomize horizontal direction
      BALL.dx = BALL.speed * (Math.random() > 0.5 ? 1 : -1);
      BALL.dy = -BALL.speed;
    }

    // Update game state
    function update() {
      if (!running) return;
      // Move paddle based on key presses
      if (rightPressed && PADDLE.x + PADDLE.w < canvas.width) {
        PADDLE.x += 7;
      } else if (leftPressed && PADDLE.x > 0) {
        PADDLE.x -= 7;
      }
      // Move ball
      BALL.x += BALL.dx;
      BALL.y += BALL.dy;
      // Wall collisions (left/right)
      if (BALL.x + BALL.r > canvas.width || BALL.x - BALL.r < 0) {
        BALL.dx = -BALL.dx;
      }
      // Top wall collision
      if (BALL.y - BALL.r < 0) {
        BALL.dy = -BALL.dy;
      }
      // Paddle collision
      if (
        BALL.y + BALL.r > PADDLE.y &&
        BALL.x > PADDLE.x &&
        BALL.x < PADDLE.x + PADDLE.w
      ) {
        BALL.dy = -BALL.dy;
        // Change horizontal direction based on where it hits the paddle
        const deltaX = BALL.x - (PADDLE.x + PADDLE.w / 2);
        BALL.dx = deltaX * 0.1;
      }
      // Bottom collision (lose life)
      if (BALL.y + BALL.r > canvas.height) {
        lives--;
        if (lives <= 0) {
          running = false;
          alert('Game Over');
          document.location.reload();
        } else {
          resetBall();
        }
      }
      // Check collisions with bricks
      collisionDetection();
    }

    // Render game elements
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBricks();
      drawPaddle();
      drawBall();
      updateInfo();
    }

    // Game loop using requestAnimationFrame
    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }
    loop();

    // Event listeners for keyboard control
    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowRight') {
        rightPressed = true;
      } else if (e.key === 'ArrowLeft') {
        leftPressed = true;
      } else if (e.code === 'Space') {
        running = !running;
        // If starting for the first time, reset ball
        if (running && BALL.y === canvas.height - 50) {
          resetBall();
        }
      }
    });
    document.addEventListener('keyup', e => {
      if (e.key === 'ArrowRight') {
        rightPressed = false;
      } else if (e.key === 'ArrowLeft') {
        leftPressed = false;
      }
    });
    // Mouse move controls for paddle
    document.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      if (x > 0 && x < canvas.width) {
        PADDLE.x = x - PADDLE.w / 2;
      }
    });
    // Slider to adjust ball speed
    document.getElementById('speed').addEventListener('input', e => {
      const val = parseFloat(e.target.value);
      BALL.speed = val;
      // Normalize direction vector and apply new speed
      const magnitude = Math.sqrt(BALL.dx * BALL.dx + BALL.dy * BALL.dy);
      BALL.dx = (BALL.dx / magnitude) * val;
      BALL.dy = (BALL.dy / magnitude) * val;
    });
  </script>
</body>
</html>